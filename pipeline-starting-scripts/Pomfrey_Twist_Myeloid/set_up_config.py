#!/bin/python3

import shutil
import sys
import argparse

# from os.path import isfile
import os
import subprocess

## Input arguments
# Initilizing parser
msg = "Script to create config-file for Pomfrey pipeline"
parser = argparse.ArgumentParser(description=msg, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
# Adding arguments
parser.add_argument("-i", "--input", help="Default config yaml-file to add your sample etc to", required=True)
parser.add_argument(
    "-s", "--sequenceid", help="Sequence id or run, which is used in naming the output files generated by Pomfrey", required=True
)
parser.add_argument("-o", "--output", help="output basename, {base}_config.yaml and {base}_order.tsv", default="SEQUENCEID")
parser.add_argument(
    "--orderfile",
    help="Sort orderfile for multiqc, --no-orderfile to not sort orderfile based on S-id in fastq-filename",
    default=True,
    action=argparse.BooleanOptionalAction,
)
parser.add_argument("-r1", "--read1-ending", help="Ending of fastq read1 to be used", default="_R1_001.fastq.gz")
parser.add_argument("-r2", "--read2-ending", help="Ending of fastq read2 to be used", default="_R2_001.fastq.gz")
parser.add_argument(
    "-fo", "--fastq-output", help="Folder that merged fastqfile end up in, fastqs for pipeline", default="fastq_merged/"
)
parser.add_argument("-fi", "--fastq-input", help="Folder that contains per lane fastqs to be merged", default="fastq/")
parser.add_argument(
    "--mergefastq",
    help="Merge per lane fastq into one file per read direction",
    default=True,
    action=argparse.BooleanOptionalAction,
)

args = parser.parse_args()
if args.output == "SEQUENCEID":
    args.output = args.sequenceid
# print(args)


# Cp default/input config to current dir to add samples to it
shutil.copyfile(args.input, args.output + "_config.yaml")

with open(args.output + "_config.yaml", "a") as configfile:
    configfile.write('\nseqID: \n    sequencerun: "' + args.sequenceid + '"\n')
    configfile.write("samples: \n")
    # Create samples list
    file_list = [args.fastq_input + "/" + x for x in os.listdir(args.fastq_input)]
    samplenames = list(set([file_name.split("/")[-1].split("_")[0] for file_name in file_list]))
    sample_order = []
    for samplename in samplenames:
        if args.mergefastq:
            # Merge per lane files into one (per direction)
            sample_files_r1 = [f for f in file_list if samplename in f and "R1" in f]
            sample_files_r2 = [f for f in file_list if samplename in f and "R2" in f]
            sample_files_r1.sort()
            sample_files_r2.sort()
            read1_cmd = "cat " + " ".join(sample_files_r1) + " > " + args.fastq_output + "/" + samplename + args.read1_ending
            read2_cmd = "cat " + " ".join(sample_files_r2) + " > " + args.fastq_output + "/" + samplename + args.read2_ending
            subprocess.run(read1_cmd, stdout=subprocess.PIPE, shell=True, check=True)
            subprocess.run(read2_cmd, stdout=subprocess.PIPE, shell=True, check=True)

            sample_order.append(sample_files_r1[0].split("_L00")[0].split("/")[-1])
            config_sample_string = (
                '    "' + samplename + '": "' + args.fastq_output + "/" + samplename + args.read1_ending + '"\n'
            )
            configfile.write(config_sample_string.replace("//", "/"))
        else:
            read_one = args.fastq_output + "/" + [f for f in file_list if samplename in f and "R1" in f][0]
            config_sample_string = '    "' + samplename + '": "' + read_one + '"\n'
            configfile.write(config_sample_string.replce("//", "/"))
            sample_order.append(read_one.split("_L00")[0].split("/")[-1])

if args.orderfile:
    sample_order.sort(key=lambda x: int(x.split("_S")[1]))

with open(args.output + "_order.tsv", "w+") as order_file:
    for samplename in sample_order:
        order_file.write(samplename.split("_S")[0] + "\n")
