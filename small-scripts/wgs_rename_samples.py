#!/bin/python3

import argparse
import sys
import itertools
import shutil
import json
import os
import logging

logging.basicConfig(
    format="{asctime} - {levelname} - {message}",
    style="{",
    datefmt="%Y-%m-%d %H:%M",
    level=logging.INFO,
)


class DefaultList(list):
    def __copy__(self):
        return []


def reset_then_exit():
    logging.debug(f"Resetting samples and units to original, then sys.exit()")
    shutil.copyfile(args.samples + args.output, args.samples)
    shutil.copyfile(args.units + args.output, args.units)
    os.remove(args.samples + args.output)
    os.remove(args.units + args.output)
    sys.exit()


# Initilize parser
msg = "Script to rename wgs samples based on bioinformatic samplesheet or samples_and_settings.json"
parser = argparse.ArgumentParser(description=msg, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
# Adding arguments
parser.add_argument(
    "-i",
    "--input",
    help="Bioinformatic samplesheet or samples_and_settings.json generated by Stackstorm defining workpackages,"
    + " experiment, analysis etc.",
    required=True,
)
parser.add_argument("-o", "--output", help="Output ending to be added to old samples and units files", default="_old")
parser.add_argument("--samples", help="Input samples.tsv file created with hydra genetics", default="samples.tsv")
parser.add_argument("--units", help="Input units.tsv file created with hydra genetics", default="units.tsv")

args = parser.parse_args()


# Cp original samples.tsv och units.tsv to keep original
logging.info("Copying samples and units to output-suffix")
logging.debug(f"{args.samples=}, {args.units=}, {args.output=}")
shutil.copyfile(args.samples, args.samples + args.output)
shutil.copyfile(args.units, args.units + args.output)


# Parse input-file, bioinfo samplesheet or samples_and_settings.json
logging.debug(f"{args.input=}")

if "samples_and_settings.json" in args.input:
    logging.info("A samples_and_settings.json file identified as input.")
    with open(args.input, "r") as samples_and_settings_file:
        data = json.load(samples_and_settings_file)

    if len(data) == 0:
        raise Exception("Empty " + args.input + "-file! ")

    logging.info("Checking that each pedigree-id/sample_id only contains one sex")
    dup_check_dict = {}
    for sample_id, sample_info in data["samples"].items():
        if sample_info["settings"]["ped"].upper() == "NA":
            sample_name = sample_id
            logging.warning(f"{sample_id} ped is set to NA, samplename will not be changed!!!")
        else:
            sample_name = sample_info["settings"]["ped"]

        if sample_name not in dup_check_dict:
            dup_check_dict[sample_name] = {}
            dup_check_dict[sample_name]["sex"] = sample_info["settings"]["sex"].upper()
        elif dup_check_dict[sample_name]["sex"] != sample_info["settings"]["sex"].upper():
            logging.error(f"Same sample ({sample_name}) have two different sexes!")
            reset_then_exit()

    logging.info(f"Create new samples.tsv file based on {args.samples}{args.output} and samples_and_settings.json.")
    with open(args.samples + args.output, "r") as samples_tsv:
        samples_outlines = []
        header_line = samples_tsv.readline().strip() + "\tsex\n"
        for lline in samples_tsv:
            line = lline.strip().upper().split("\t")
            if line[0] in data["samples"].keys():
                ped_name = (
                    line[0]
                    if data["samples"][line[0]]["settings"]["ped"].upper() == "NA"
                    else data["samples"][line[0]]["settings"]["ped"].upper()
                )
                tc = line[1]
                if data["samples"][line[0]]["settings"]["sex"].upper() == "F":
                    data["samples"][line[0]]["settings"]["sex"] = "K"
                sex = data["samples"][line[0]]["settings"]["sex"].upper()
                if sex != "M" and sex != "K" and sex != "O":
                    logging.error(f"Sex is neither M|K|O for sample {line[0]}. {sex=}")
                    reset_then_exit()
                samples_outlines.append([ped_name, tc, sex])
            else:
                logging.error(f"The D(/R)NA-number {line[0]} is not included in {args.input}.")
                reset_then_exit()

    logging.debug("Removing duplicates lines in samples_outlines.")
    with open(args.samples, "w+") as samples_out:
        samples_out.write(header_line)
        # Remove duplicate rows
        samples_outlines.sort()
        for samples_outline in [samples_outlines for samples_outlines, _ in itertools.groupby(samples_outlines)]:
            samples_out.write("\t".join(samples_outline) + "\n")

    # Read units.tsv_old and create new units.tsv file
    logging.info(f"Create new units.tsv based on {args.units}{args.output} and samples_and_settings.json.")
    units_outlines = []
    with open(args.units + args.output, "r") as units_tsv:
        units_outlines = []
        header_line = units_tsv.readline()
        for lline in units_tsv:
            line = lline.strip().split("\t")
            if line[0] in data["samples"].keys():
                ped_name = (
                    line[0]
                    if data["samples"][line[0]]["settings"]["ped"].upper() == "NA"
                    else data["samples"][line[0]]["settings"]["ped"].upper()
                )
                if (
                    data["samples"][line[0]]["analysis"].upper() == "IHT"
                    and data["samples"][line[0]]["settings"]["fragestallning"].upper() != "R"
                ):
                    sample_type = "R"
                    logging.warning(
                        f"D(/R)NA-number {line[0]} identified as IHT analysis and fragestallning not R."
                        + " Sample_type still set to R."
                    )
                    logging.debug(f'{data["samples"][line[0]]["settings"]=}')
                else:
                    sample_type = data["samples"][line[0]]["settings"]["fragestallning"].upper()

                if sample_type != "T" and sample_type != "N" and sample_type != "R":
                    logging.error(
                        f"{line[0]} does not have T|N|R as sample_type. "
                        + f"{sample_type=}, {data['samples'][line[0]]['settings']['fragestallning']=}"
                    )
                    reset_then_exit()
                outline = [ped_name, sample_type] + line[2:]
                units_outlines.append(outline)

            else:
                logging.error(f"The D(/R)NA-number {line[0]} is not included in {args.input}.")
                sys.exit()

    logging.info(f"Check that all barcodes match for each sample-type combo.")
    barcode_check = {}
    header_index = header_line.strip().split("\t")
    for unit_line in units_outlines:
        sample_type = unit_line[header_index.index("sample")] + "_" + unit_line[header_index.index("type")]
        if sample_type not in barcode_check.keys():
            barcode_check[sample_type] = [unit_line[header_index.index("barcode")]]
        elif unit_line[header_index.index("barcode")] not in barcode_check[sample_type]:
            logging.debug(
                f"New barcode for {sample_type}. {unit_line[header_index.index('barcode')]=} {barcode_check[sample_type]=}"
            )
            barcode_check[sample_type].append(unit_line[header_index.index("barcode")])
        else:
            logging.debug(
                f"Same barcode already in list. {unit_line[header_index.index('barcode')]=} {barcode_check[sample_type]=}"
            )

    for key in list(barcode_check.keys()):
        if len(barcode_check[key]) == 1:
            del barcode_check[key]

    logging.debug(f"Writing to {args.units}")
    with open(args.units, "w+") as units_out:
        units_out.write(header_line)
        for units_outline in units_outlines:
            sample_type = units_outline[header_index.index("sample")] + "_" + units_outline[header_index.index("type")]
            if sample_type in barcode_check:
                logging.debug(f"Original: {units_outline=}")
                units_outline[header_index.index("barcode")] = barcode_check[sample_type][0]
                logging.warning(
                    f"More than one different barcodes identified for {sample_type}. "
                    + f"All values set to {barcode_check[sample_type][0]}!!!"
                )
                logging.debug(f"{units_outline=}.{barcode_check[sample_type]=}")
                logging.debug(f"Updated: {units_outline=}")
            units_out.write("\t".join(units_outline) + "\n")

else:
    logging.info(f"Input ({args.input}) is identified as old bioinfo-format")
    # old version
    samplesheet_dict = {}
    with open(args.input, "r") as samplesheet:
        header_line = samplesheet.readline().lower().strip().split(",")
        for lline in samplesheet:
            line = lline.strip().upper().split(",")

            logging.debug(f"Building the samplesheet dict")
            samplesheet_dict[line[header_line.index("sample_id")]] = {}
            i = 0
            for column in header_line:
                if column == "description":
                    i += 1
                    for description_field in line[header_line.index("description")].split("%"):
                        samplesheet_dict[line[header_line.index("sample_id")]][description_field.split(":")[0].lower()] = (
                            description_field.split(":")[1]
                        )
                else:
                    samplesheet_dict[line[header_line.index("sample_id")]][header_line[i]] = line[i]
                    i += 1

    # Check that pedigree id/trio does not have two or more sex
    logging.info(f"Checking that each pedigree-id/sample_id only contains one sex")
    dup_check_dict = {}
    for sample_id, sample_info in samplesheet_dict.items():
        if sample_info["ped"].upper() == "NA":
            sample_name = sample_id
            logging.warning(f"{sample_id} ped is set to NA, samplename will not be changed!!!")
        else:
            sample_name = sample_info["ped"]

        if sample_name not in dup_check_dict:
            dup_check_dict[sample_name] = {}
            dup_check_dict[sample_name]["sex"] = sample_info["sex"]
            dup_check_dict[sample_name]["cgu-project"] = sample_info["cgu-project"]
        elif dup_check_dict[sample_name]["sex"] != sample_info["sex"]:
            logging.error(f"Sample sample ({sample_name}) have two different sexes.")
            reset_then_exit()

    # samples.tsv file
    logging.info(f"Creating the new {args.samples}.")
    with open(args.samples, "w+") as outfile:
        with open(args.samples + args.output, "r") as samples_tsv:
            outlines = []
            header_line = samples_tsv.readline().strip() + "\tsex\n"
            outfile.write(header_line)
            for lline in samples_tsv:
                line = lline.strip().upper().split("\t")
                if line[0] in samplesheet_dict.keys():
                    ped_name = (
                        line[0] if samplesheet_dict[line[0]]["ped"].upper() == "NA" else samplesheet_dict[line[0]]["ped"].upper()
                    )
                    tc = line[1]
                    if samplesheet_dict[line[0]]["sex"].upper() == "F":
                        samplesheet_dict[line[0]]["sex"] = "K"
                    sex = samplesheet_dict[line[0]]["sex"]
                    if sex.upper() != "M" and sex.upper() != "K" and sex.upper() != "O":
                        logging.error(f"Sex id neither M|K|O for {line[0]}. {sex=}")
                        reset_then_exit()

                    outlines.append([ped_name.upper(), tc, sex.upper()])
                else:
                    logging.error(f"The D(/R)NA-number {line[0]} is not included in {args.input}.")
                    reset_then_exit()

        logging.debug("Removing duplicates lines in samples_outlines.")
        outlines.sort()
        for outline in [outlines for outlines, _ in itertools.groupby(outlines)]:
            outfile.write("\t".join(outline) + "\n")

    # units.tsv file
    logging.info(f"Creating new {args.units}")
    units_outlines = []
    with open(args.units + args.output, "r") as units_tsv:
        header_line = units_tsv.readline()

        for lline in units_tsv:
            line = lline.strip().split("\t")
            if line[0] in samplesheet_dict.keys():
                ped_name = (
                    line[0] if samplesheet_dict[line[0]]["ped"].upper() == "NA" else samplesheet_dict[line[0]]["ped"].upper()
                )
                sample_type = samplesheet_dict[line[0]]["fragestallning"]
                if sample_type.lower() == "heltranskriptom":
                    logging.warning(f"Fragestallning set to heltranskriptom for {ped_name}, sample_type set still set to R.")
                    sample_type = "R"
                if sample_type != "T" and sample_type != "N" and sample_type != "R":
                    logging.error(
                        f"Sample type/fragestallning set to neither T|N|R|heltranskriptom for {ped_name}. {sample_type=}"
                    )
                    reset_then_exit()
                outline = [ped_name.upper(), sample_type] + line[2:]
                units_outlines.append(outline)
            else:
                logging.error(f"The D(/R)NA-number {line[0]} is not included in {args.input}.")
                reset_then_exit()

    logging.info(f"Check that all barcodes match for each sample-type combo.")
    barcode_check = {}
    header_index = header_line.strip().split("\t")
    for unit_line in units_outlines:
        sample_type = unit_line[header_index.index("sample")] + "_" + unit_line[header_index.index("type")]
        if sample_type not in barcode_check.keys():
            barcode_check[sample_type] = [unit_line[header_index.index("barcode")]]
        elif unit_line[header_index.index("barcode")] not in barcode_check[sample_type]:
            logging.debug(
                f"New barcode for {sample_type}. {unit_line[header_index.index('barcode')]=} {barcode_check[sample_type]=}"
            )
            barcode_check[sample_type].append(unit_line[header_index.index("barcode")])
        else:
            logging.debug(
                f"Same barcode already in list. {unit_line[header_index.index('barcode')]=} {barcode_check[sample_type]=}"
            )

    for key in list(barcode_check.keys()):
        if len(barcode_check[key]) == 1:
            del barcode_check[key]

    logging.debug(f"Writing to {args.units}")
    with open(args.units, "w+") as units_out:
        units_out.write(header_line)
        for units_outline in units_outlines:
            sample_type = units_outline[header_index.index("sample")] + "_" + units_outline[header_index.index("type")]
            if sample_type in barcode_check:
                logging.debug(f"Original: {units_outline=}")
                units_outline[header_index.index("barcode")] = barcode_check[sample_type][0]
                logging.warning(
                    f"More than one different barcodes identified for {sample_type}."
                    + f" All values set to {barcode_check[sample_type][0]}!!!"
                )
                logging.debug(f"{units_outline=}.{barcode_check[sample_type]=}")
                logging.debug(f"Updated: {units_outline=}")
            units_out.write("\t".join(units_outline) + "\n")
